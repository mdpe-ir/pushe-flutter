import 'dart:async';
import 'dart:convert';

import 'package:flutter/services.dart';

///
/// @author Mahdi Malvandi
/// Main plugin class handling most of SDK's works.
///
class Pushe {
  // Callback handlers
  static void Function(NotificationData) _receiveCallback;
  static void Function(NotificationData) _clickCallback;
  static void Function(NotificationData) _dismissCallback;
  static void Function(dynamic) _customContentCallback;
  static void Function(NotificationData, NotificationButtonData)
      _buttonClickCallback;

  static const MethodChannel _channel = const MethodChannel('Pushe');

  /// Get the unique id of the devices generated by android id or ad id
  static Future<String> getAndroidId() async =>
      await _channel.invokeMethod("Pushe.getAndroidId");

  /// Get google advertising id
  static Future<String> getGoogleAdvertisingId() async =>
      await _channel.invokeMethod("Pushe.getGoogleAdvertisingId");

  /// Get custom id
  static Future<String> getCustomId() async =>
      await _channel.invokeMethod("Pushe.getCustomId");

  /// Set custom id
  static Future<void> setCustomId(String id) async =>
      _channel.invokeMethod("Pushe.setCustomId", {"id": id});

  /// Get email
  static Future<String> getUserEmail() async =>
      await _channel.invokeMethod("Pushe.getUserEmail");

  /// Set email
  static Future<void> setUserEmail(String email) async =>
      _channel.invokeMethod("Pushe.setUserEmail", {"email": email});

  /// Get user phone number
  static Future<String> getUserPhoneNumber() async =>
      await _channel.invokeMethod("Pushe.getUserPhoneNumber");

  /// Set user phone number
  static Future<void> setUserPhoneNumber(String phone) async =>
      _channel.invokeMethod("Pushe.setUserPhoneNumber", {"phone": phone});

  /// Add tags.
  /// [tags] key-value pairs
  /// [callback] is an optional function that will be called with result of adding tags.
  static Future<void> addTags(Map tags, {Function(bool) callback}) async {
    var result = await _channel.invokeMethod("Pushe.addTags", {"tags": tags});
    callback?.call(result);
  }

  /// Remove tags.
  /// [tags] list of tag keys to remove
  /// [callback] is an optional function that will be called with result of removing tags.
  static Future<void> removeTags(List tags, {Function(bool) callback}) async {
    var result =
        await _channel.invokeMethod("Pushe.removeTags", {"tags": tags});
    callback?.call(result);
  }

  /// Get subscribed tags
  static Future<Map> getSubscribedTags() async =>
      await _channel.invokeMethod("Pushe.getSubscribedTags");

  /// Get subscribed topics
  static Future<List> getSubscribedTopics() async =>
      await _channel.invokeMethod("Pushe.getSubscribedTopics");

  /// Subscribe to a topic.
  /// [topic] is the name of that topic. The naming rules must follow FCM topic naming standards.
  /// [callback] is an optional function that will be called with result of subscription.
  static Future<void> subscribe(String topic, {Function(bool) callback}) async {
    var result =
        await _channel.invokeMethod("Pushe.subscribe", {"topic": topic});
    callback?.call(result);
  }

  /// Unsubscribe from a topic already subscribed.
  /// [topic] is the name of that topic. The naming rules must follow FCM topic naming standards.
  /// [callback] is an optional function that will be called with result of Unsubscription.
  static Future<void> unsubscribe(String topic,
      {Function(bool) callback}) async {
    var result =
        await _channel.invokeMethod("Pushe.unsubscribe", {"topic": topic});
    callback?.call(result);
  }

  /// If this function is called, notification will not be shown.
  static Future<void> setNotificationOff() async =>
      _channel.invokeMethod("Pushe.setNotificationOff");

  /// Default of notification is set to On, if you have set it off, you can revert it using this function.
  static Future<void> setNotificationOn() async =>
      _channel.invokeMethod("Pushe.setNotificationOn");

  static Future<bool> isNotificationOn() async =>
      _channel.invokeMethod("Pushe.isNotificationOn");

  /// Check if Pushe is initialized to server or not.
  static Future<bool> isInitialized() async =>
      await _channel.invokeMethod("Pushe.isInitialized");

  /// Check if Pushe is registered to server or not.
  static Future<bool> isRegistered() async =>
      await _channel.invokeMethod("Pushe.isRegistered");

  /// Call it's callback when registration is completed
  static Future<void> setRegistrationCompleteListener(Function callback) async {
    var result =
        await _channel.invokeMethod("Pushe.setRegistrationCompleteListener");
    if (result) callback?.call();
  }

  /// Call it's callback when initialization is completed
  static Future<void> setInitializationCompleteListener(
      Function callback) async {
    var result =
        await _channel.invokeMethod("Pushe.setInitializationCompleteListener");
    if (result) callback?.call();
  }

  /// To send a simple notification to another user using his/her android Id
  static Future<void> sendNotificationToUser(
          String androidId, String title, String content) async =>
      _channel.invokeMethod("Pushe.sendNotificationToUser",
          {"androidId": androidId, "title": title, "content": content});

  ///Send an event
  ///[name] is the name of event that wants to send
  static Future<void> sendEvent(String name) async =>
      _channel.invokeMethod("Pushe.sendEvent", {"name": name});

  /// Send ecommerce data.
  /// [name] is the name of ecommerce data
  /// [price] is the value of ecommerce name
  static Future<void> sendEcommerceData(String name, double price) async =>
      _channel.invokeMethod(
          "Pushe.sendEcommerceData", {"name": name, "price": price});

  /// Set callbacks for different types of events for notifications (in foreground or when app is open in the background)
  /// [onReceived] is called when notification was received.
  /// [onClicked] is called when notification was clicked.
  /// [onDismissed] is called when notification was swiped away.
  /// [onButtonClicked] is called when notification contains button and a button was clicked.
  /// [onCustomContentReceived] is called when notification includes custom json. It will a json in string format.
  /// [applicationOverridden] : If you have added [android:name="co.pushe.plus.flutter.PusheApplication"] to your AndroidManifest application attribute,
  /// the callbacks will be callable since user starts the app. But if not, callbacks will be available when you call [setNotificationListener] and before that callbacks won't work.
  /// This doesn't make so much difference. But in future case when Flutter added background fcm support, this can make difference.
  static setNotificationListener(
      {Function(NotificationData) onReceived,
      Function(NotificationData) onClicked,
      Function(NotificationData) onDismissed,
      Function(NotificationData, NotificationButtonData) onButtonClicked,
      Function(dynamic) onCustomContentReceived,
      bool applicationOverridden: false}) {
    _receiveCallback = onReceived;
    _clickCallback = onClicked;
    _dismissCallback = onDismissed;
    _buttonClickCallback = onButtonClicked;
    _customContentCallback = onCustomContentReceived;
    _channel.setMethodCallHandler(_handleMethod);
    if (!applicationOverridden) {
      _channel.invokeMethod("Pushe.initNotificationListenerManually");
    }
  }

  ///
  /// If a method was called from native code through channel this will handle it.
  ///
  static Future<Null> _handleMethod(MethodCall call) async {
    print('Call: ${call.method}');
    print('Call arg: ${call.arguments}');

    dynamic arg = jsonDecode(call.arguments);

    if (call.method == 'Pushe.onNotificationReceived') {
      _receiveCallback?.call(NotificationData.fromJson(arg['data']));
    } else if (call.method == 'Pushe.onNotificationClicked') {
      _clickCallback?.call(NotificationData.fromJson(arg['data']));
    } else if (call.method == 'Pushe.onNotificationButtonClicked') {
      try {
        _buttonClickCallback?.call(NotificationData.fromJson(arg['data']), NotificationButtonData.fromJsonString(arg['button']));
      } catch (e) {
        print('Pushe: Error passing notification data to callback ${e.toString()}');
      }
    } else if (call.method == 'Pushe.onCustomContentReceived') {
      try {
        var customContent = arg['json'];
        _customContentCallback?.call(customContent);
      } catch (e) {
        print('Pushe: Error passing customContent to callback');
      }
    } else if (call.method == 'Pushe.onNotificationDismissed') {
      _dismissCallback?.call(NotificationData.fromJson(arg['data']));
    }
    return null;
  }
}

///
/// Notification data class as an interface between native callback data classes and Flutter dart code.
/// When a notification event happens (like Receive), callbacks will hold instances of this class.
///
class NotificationData {
  String _title,
      _content,
      _bigTitle,
      _bigContent,
      _summary,
      _imageUrl,
      _iconUrl;
  dynamic _customContent;
  List<NotificationButtonData> _buttons;

  NotificationData._();

  NotificationData.create(
      this._title,
      this._content,
      this._bigTitle,
      this._bigContent,
      this._summary,
      this._imageUrl,
      this._iconUrl,
      this._customContent,
      this._buttons);

  static NotificationData fromJson(dynamic data) {
    try {
      List<NotificationButtonData> notificationButtons;
      try {
        notificationButtons = NotificationButtonData.fromDynamic(data['buttons']);
      } catch (e) {
        notificationButtons = null;
      }
      return NotificationData.create(
          data['title'],
          data['content'],
          data['bigTitle'],
          data['bigContent'],
          data['summary'],
          data['imageUrl'],
          data['iconUrl'],
          data['json'],
          notificationButtons);
    } catch (e) {
      print('Error getting notification data from json\nError:$e\nJson:$data');
      return null;
    }
  }

  @override
  String toString() =>
      'NotificationData{_title: $_title, _content: $_content, _bigTitle: $_bigTitle, _bigContent: $_bigContent, _summary: $_summary, _imageUrl: $_imageUrl, _iconUrl: $_iconUrl, _customContent: $_customContent, buttons: $_buttons}';

  get customContent => _customContent;

  get iconUrl => _iconUrl;

  get imageUrl => _imageUrl;

  get summary => _summary;

  get bigContent => _bigContent;

  get bigTitle => _bigTitle;

  get content => _content;

  get title => _title;

  get buttons => _buttons;
}

///
/// When there are buttons in the notification they are accessible through callbacks.
/// For every button there would be an object in the callback notification data object.
/// And also when a button is clicked, it's id and text will be passes separately in `onNotificationButtonClicked` callback.
class NotificationButtonData {
  String _text;
  int _id;

  NotificationButtonData._();

  NotificationButtonData.create(this._text, this._id);

  int get id => _id;

  String get text => _text;

  @override
  String toString() => 'NotificationButtonData{_text: $_text, _id: $_id}';

  static NotificationButtonData fromMap(dynamic d) {
    var data = jsonDecode(d);
    try {
      return NotificationButtonData.create(data['title'], data['icon']);
    } catch (e) {
      print('Error getting button from json\nError:$e\nJson:$data');
      return null;
    }
  }

  static NotificationButtonData fromJsonString(dynamic json) {
    return fromMap(json);
  }

  static List<NotificationButtonData> fromDynamic(dynamic buttons) {
    return buttons.map((item) {
      print('Button: $item');
      return NotificationButtonData.create(item['title'], item['icon']);
    });
  }

  static List<NotificationButtonData> fromJsonList(dynamic json) {
    try {
      var result = (json as List<dynamic>).map((item) {
        print('Button: $item');
        return fromMap(item);
      });
      return result.toList();
    } catch (e) {
      print(
          'Error getting button list from notification\nError:$e\nJson:$json');
      return null;
    }
  }
}
