import 'dart:async';

import 'package:flutter/services.dart';

///
/// @author Mahdi Malvandi
///
class Pushe {

  // Callback handlers
  static void Function(String) _receiveCallback;
  static void Function(String) _clickCallback;
  static void Function(String) _dismissCallback;
  static void Function(String) _customContentCallback;
  static void Function(String, String) _buttonClickCallback;



  static const MethodChannel _channel = const MethodChannel('Pushe');

  /// To start registering Pushe, you will call this method.
  /// [showDialog]: If device had no GooglePlayServices or it was old, a dialog will appear to let user update it using any market.
  static Future<void> initialize({bool showDialog: true}) async => _channel.invokeMethod('Pushe#initialize', {"showDialog":showDialog});

  /// Get the unique id of the devices generated by android id or ad id
  static Future<String> getPusheId() async => await _channel.invokeMethod("Pushe#getPusheId");

  /// Subscribe to a topic.
  /// [topic] is the name of that topic. The naming rules must follow FCM topic naming standards.
  static Future<void> subscribe(String topic) async => _channel.invokeMethod("Pushe#subscribe", {"topic":topic});

  /// Unsubscribe from a topic already subscribed.
  static Future<void> unsubscribe(String topic) async => _channel.invokeMethod("Pushe#unsubscribe", {"topic":topic});

  /// If this function is called, notification will not be shown.
  static Future<void> setNotificationOff() async => _channel.invokeMethod("Pushe#setNotificationOff");

  /// Default of notification is set to On, if you have set it off, you can revert it using this function.
  static Future<void> setNotificationOn() async => _channel.invokeMethod("Pushe#setNotificationOn");

  /// Check if Pushe is registered to server or not. This method is not completely reliable.
  static Future<bool> isPusheInitialized() async => await _channel.invokeMethod("Pushe#isPusheInitialized");

  /// To send a simple notification to another user using his/her PusheId
  static Future<void> sendSimpleNotifToUser(String pusheId, String title, String content) async => _channel.invokeMethod("Pushe#sendSimpleNotifToUser", {"pusheId":pusheId, "title":title, "content":content});

  /// To send a JSON formatted advanced notification to another device using it's PusheId
  static Future<void> sendAdvancedNotifToUser(String pusheId, String notificationJson) async => _channel.invokeMethod("Pushe#sendSimpleNotifToUser", {"pusheId":pusheId, "json":notificationJson});

  /// If you want to receive callbacks when notification is received/clicked/dismissed/button clicked or custom content is received,
  /// you call this function to let the plugin initialize callback receivers.
  /// [withManifestOverrode]: If set to false it will manually register the receiver, (default choice)
  /// If set to true, you must have added PusheApplication as your application class in the manifest or you have called
  /// [PusheApplication.initializeNotificationListeners(context.getApplicationContext())] in your application#onCreate.
  /// Chance of getting callback using application class (When app is closed) is more than normal callbacks.
  /// If you use normal callbacks you have to call this method every time to add listener.
  static Future<void> initializeNotificationListeners({bool withManifestOverrode:false}) async {
    _channel.setMethodCallHandler(_handleMethod);
    if (!withManifestOverrode) {
      _channel.invokeMethod("Pushe#initNotificationListenerManually");
    }
  }

  // callbacks
  static setOnNotificationReceived(Function(String) f) => _receiveCallback = f;
  static setOnNotificationClicked(Function(String) f) => _clickCallback = f;
  static setOnNotificationButtonClicked(Function(String, String) f) => _buttonClickCallback = f;
  static setOnNotificationCustomContentReceived(Function(String) f) => _customContentCallback = f;
  static setOnNotificationDismissed(Function(String) f) => _dismissCallback = f;



  ///
  /// If a method was called from native code through channel this will handle it.
  ///
  static Future<Null> _handleMethod(MethodCall call) async {
    if (call.method == 'Pushe#onNotificationReceived') {
      _receiveCallback?.call(call.arguments);
    } else if (call.method == 'Pushe#onNotificationClicked') {
    _clickCallback?.call(call.arguments);
    } else if (call.method == 'Pushe#onNotificationButtonClicked') {
      _buttonClickCallback?.call(call.arguments, call.arguments);
    } else if (call.method == 'Pushe#onNotificationCustomContentReceived') {
      _customContentCallback?.call(call.arguments);
    } else if (call.method == 'Pushe#onNotificationDismissed') {
      _dismissCallback?.call(call.arguments);
    }
    return null;
  }
}
