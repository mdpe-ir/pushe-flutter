import 'dart:async';
import 'dart:convert';
import 'dart:ui';

import 'package:flutter/services.dart';

///
/// Enum: Notification id type
/// @author Mahdi Malvandi
///
enum IdType {
  AndroidId,
  GoogleAdvertisingId,
  CustomId
}

void _pusheSetupBackgroundChannel() {
  
}

///
/// @author Mahdi Malvandi
/// Main plugin class handling most of SDK's works.
///
class Pushe {
  // Callback handlers
  static void Function(NotificationData) _receiveCallback;
  static void Function(NotificationData) _clickCallback;
  static void Function(NotificationData) _dismissCallback;
  static void Function(dynamic) _customContentCallback;
  static void Function(NotificationData, NotificationButtonData)
      _buttonClickCallback;

  static const MethodChannel _channel = const MethodChannel('plus.pushe.co/pushe_flutter');

  /// Get the unique id of the devices generated by android id or ad id
  static Future<String> getAndroidId() async =>
      await _channel.invokeMethod("Pushe.getAndroidId");

  /// Get google advertising id
  static Future<String> getGoogleAdvertisingId() async =>
      await _channel.invokeMethod("Pushe.getGoogleAdvertisingId");

  /// Get custom id
  static Future<String> getCustomId() async =>
      await _channel.invokeMethod("Pushe.getCustomId");

  /// Set custom id
  static Future<void> setCustomId(String id) async =>
      await _channel.invokeMethod("Pushe.setCustomId", {"id": id});

  /// Get email
  static Future<String> getUserEmail() async =>
      await _channel.invokeMethod("Pushe.getUserEmail");

  /// Set email
  static Future<void> setUserEmail(String email) async =>
      await _channel.invokeMethod("Pushe.setUserEmail", {"email": email});

  /// Get user phone number
  static Future<String> getUserPhoneNumber() async =>
      await _channel.invokeMethod("Pushe.getUserPhoneNumber");

  /// Set user phone number
  static Future<void> setUserPhoneNumber(String phone) async =>
      await _channel.invokeMethod("Pushe.setUserPhoneNumber", {"phone": phone});

  /// Add tags.
  /// [tags] key-value pairs
  /// [callback] is an optional function that will be called with result of adding tags.
  static Future<void> addTags(Map<String, String> tags, {Function callback}) async {
    if (await _channel.invokeMethod("Pushe.addTags", {"tags": tags})) {
      callback?.call();
    }
    return;
  }

  /// Remove tags.
  /// [tags] list of tag keys to remove
  /// [callback] is an optional function that will be called with result of removing tags.
  static Future<void> removeTags(List<String> tags, {Function callback}) async {
    if (await _channel.invokeMethod("Pushe.removeTags", {"tags": tags})) {
      callback?.call();
    }
    return;
  }

  /// Get subscribed tags
  static Future<Map> getSubscribedTags() async =>
      await _channel.invokeMethod("Pushe.getSubscribedTags");

  /// Get subscribed topics
  static Future<List> getSubscribedTopics() async =>
      await _channel.invokeMethod("Pushe.getSubscribedTopics");

  /// Subscribe to a topic.
  /// [topic] is the name of that topic. The naming rules must follow FCM topic naming standards.
  /// [callback] is an optional function that will be called with result of subscription.
  static Future<void> subscribe(String topic, {Function callback}) async {
    if (await _channel.invokeMethod("Pushe.subscribe", {"topic": topic})) {
      callback?.call();
    }
    return;
  }

  /// Unsubscribe from a topic already subscribed.
  /// [topic] is the name of that topic. The naming rules must follow FCM topic naming standards.
  /// [callback] is an optional function that will be called with result of Unsubscription.
  static Future<void> unsubscribe(String topic,
      {Function callback}) async {
    if (await _channel.invokeMethod("Pushe.unsubscribe", {"topic": topic})) {
      callback?.call();
    }
    return;
  }

  /// If this function is called, notification will not be shown.
  static Future<void> setNotificationOff() async =>
      await _channel.invokeMethod("Pushe.setNotificationOff");

  /// Default of notification is set to On, if you have set it off, you can revert it using this function.
  static Future<void> setNotificationOn() async =>
      await _channel.invokeMethod("Pushe.setNotificationOn");

  static Future<bool> isNotificationOn() async =>
      await _channel.invokeMethod("Pushe.isNotificationOn");

  /// Check if Pushe is initialized to server or not.
  static Future<bool> isInitialized() async =>
      await _channel.invokeMethod("Pushe.isInitialized");

  /// Check if Pushe is registered to server or not.
  static Future<bool> isRegistered() async =>
      await _channel.invokeMethod("Pushe.isRegistered");

  /// Call it's callback when registration is completed
  static Future<void> setRegistrationCompleteListener(Function callback) async {
    var result =
        await _channel.invokeMethod("Pushe.setRegistrationCompleteListener");
    if (result) callback?.call();
    return;
  }

  /// Call it's callback when initialization is completed
  static Future<void> setInitializationCompleteListener(
      Function callback) async {
    var result =
        await _channel.invokeMethod("Pushe.setInitializationCompleteListener");
    if (result) callback?.call();
    return;
  }

  ///
  /// Sending notification from this device to another device which is registered as a user of this app.
  /// [type] is the type of unique id which you are passing
  /// [id] is the id of the type [type]
  /// [title] is the title of the notification
  /// [content] is the content of the notification
  /// [bigTitle] is the complete title of the notification
  /// [bigContent] is the complete content of the notification
  /// [imageUrl] is the url of the image which notification can contain
  /// [iconUrl] is the url of the notification icon
  /// [customContent] is the custom json you send along with the notification message which can be received as the notification customContent in the target device
  static Future<void> sendNotificationToUser(
      IdType type,
      String id,
      String title,
      String content,
      {String bigTitle, String bigContent, String imageUrl, String iconUrl, String notifIcon, dynamic customContent}
      ) async {
    String idType = type.toString();
    await _channel.invokeMethod('Pushe.sendUserNotification', {
      "type":idType,
      "id":id,
      "title":title,
      "content":content,
      "bigTitle":bigTitle,
      "bigContent":bigContent,
      "imageUrl":imageUrl,
      "iconUrl":iconUrl,
      "notifIcon":notifIcon,
      "customContent":jsonEncode(customContent)
    });
    return;
  }

  static Future<void> sendAdvancedNotificationToUser(IdType type, String id, String json) async {
    String idType = type.toString();
    await _channel.invokeMethod('Pushe.sendAdvancedUserNotification', {
      "type":idType,
      "id":id,
      "advancedJson":jsonEncode(json)
    });
    return;
  }

  ///Send an event
  ///[name] is the name of event that wants to send
  /// Possible option: SendEvent
  static Future<void> sendEvent(String name) async =>
      await _channel.invokeMethod("Pushe.sendEvent", {"name": name});

  /// Send ecommerce data.
  /// [name] is the name of ecommerce data
  /// [price] is the value of ecommerce name
  static Future<void> sendEcommerceData(String name, double price) async =>
      await _channel.invokeMethod(
          "Pushe.sendEcommerceData", {"name": name, "price": price});

  /// Set callbacks for different types of events for notifications (in foreground or when app is open in the background)
  /// [onReceived] is called when notification was received.
  /// [onClicked] is called when notification was clicked.
  /// [onDismissed] is called when notification was swiped away.
  /// [onButtonClicked] is called when notification contains button and a button was clicked.
  /// [onCustomContentReceived] is called when notification includes custom json. It will a json in string format.
  /// [applicationOverridden] : If you have added [android:name="co.pushe.plus.flutter.PusheApplication"] to your AndroidManifest application attribute,
  /// the callbacks will be callable since user starts the app. But if not, callbacks will be available when you call [setNotificationListener] and before that callbacks won't work.
  /// This doesn't make so much difference. But in future case when Flutter added background fcm support, this can make difference.
  static Future<void> setNotificationListener(
      {Function(NotificationData) onReceived,
      Function(NotificationData) onClicked,
      Function(NotificationData) onDismissed,
      Function(NotificationData, NotificationButtonData) onButtonClicked,
      Function(dynamic) onCustomContentReceived,
      bool applicationOverridden: false}) async {
    _receiveCallback = onReceived;
    _clickCallback = onClicked;
    _dismissCallback = onDismissed;
    _buttonClickCallback = onButtonClicked;
    _customContentCallback = onCustomContentReceived;
    _channel.setMethodCallHandler(_handleMethod);
    final CallbackHandle backgroundSetupHandle = PluginUtilities.getCallbackHandle(_pusheSetupBackgroundChannel);

    if (!applicationOverridden) {
      _channel.invokeMethod("Pushe.initNotificationListenerManually");
    }
    return;
  }

  ///
  /// If a method was called from native code through channel this will handle it.
  ///
  static Future<Null> _handleMethod(MethodCall call) async {
    dynamic arg = jsonDecode(call.arguments);

    if (call.method == 'Pushe.onNotificationReceived') {
      _receiveCallback?.call(NotificationData.fromJson(arg['data']));
    } else if (call.method == 'Pushe.onNotificationClicked') {
      _clickCallback?.call(NotificationData.fromJson(arg['data']));
    } else if (call.method == 'Pushe.onNotificationButtonClicked') {
      try {
        _buttonClickCallback?.call(NotificationData.fromJson(arg['notification']['data']), NotificationButtonData.fromMap(arg['button']));
      } catch (e) {
        print('Pushe: Error passing notification data to callback ${e.toString()}');
      }
    } else if (call.method == 'Pushe.onCustomContentReceived') {
      try {
        var customContent = arg['json'];
        _customContentCallback?.call(customContent);
      } catch (e) {
        print('Pushe: Error passing customContent to callback');
      }
    } else if (call.method == 'Pushe.onNotificationDismissed') {
      _dismissCallback?.call(NotificationData.fromJson(arg['data']));
    }
    return null;
  }
}

///
/// Notification data class as an interface between native callback data classes and Flutter dart code.
/// When a notification event happens (like Receive), callbacks will hold instances of this class.
///
class NotificationData {
  String _title,
      _content,
      _bigTitle,
      _bigContent,
      _summary,
      _imageUrl,
      _iconUrl;
  dynamic _customContent;
  List<NotificationButtonData> _buttons;

  NotificationData._();

  NotificationData.create(
      this._title,
      this._content,
      this._bigTitle,
      this._bigContent,
      this._summary,
      this._imageUrl,
      this._iconUrl,
      this._customContent,
      this._buttons);

  static NotificationData fromJson(dynamic data) {
    try {
      List<NotificationButtonData> notificationButtons;
      try {
        notificationButtons = NotificationButtonData.fromList(data['buttons']);
      } catch (e) {
        notificationButtons = null;
      }
      return NotificationData.create(
          data['title'],
          data['content'],
          data['bigTitle'],
          data['bigContent'],
          data['summary'],
          data['imageUrl'],
          data['iconUrl'],
          data['json'],
          notificationButtons);
    } catch (e) {
      print('Error getting notification data from json\nError:$e\nJson:$data');
      return null;
    }
  }

  @override
  String toString() =>
      'NotificationData{_title: $_title, _content: $_content, _bigTitle: $_bigTitle, _bigContent: $_bigContent, _summary: $_summary, _imageUrl: $_imageUrl, _iconUrl: $_iconUrl, _customContent: $_customContent, buttons: $_buttons}';

  get customContent => _customContent;

  get iconUrl => _iconUrl;

  get imageUrl => _imageUrl;

  get summary => _summary;

  get bigContent => _bigContent;

  get bigTitle => _bigTitle;

  get content => _content;

  get title => _title;

  get buttons => _buttons;
}

///
/// When there are buttons in the notification they are accessible through callbacks.
/// For every button there would be an object in the callback notification data object.
/// And also when a button is clicked, it's id and text will be passes separately in `onNotificationButtonClicked` callback.
class NotificationButtonData {
  String _title;
  String _icon;

  NotificationButtonData._();

  NotificationButtonData.create(this._title, this._icon);

  String get title => _title;
  String get icon => _icon;

  @override
  String toString() => 'NotificationButtonData{_title: $_title, _icon: $_icon}';

  static NotificationButtonData fromMap(dynamic data) {
    try {
      return NotificationButtonData.create(data['title'], data['icon']);
    } catch (e) {
      print('Error getting button from json\nError:$e\nJson:$data');
      return null;
    }
  }

  static List<NotificationButtonData> fromList(dynamic buttons) {
    List<dynamic> list = buttons;
    List<NotificationButtonData> buttonDataList = new List();
    for(var i in list) {
      buttonDataList.add(NotificationButtonData.create(i['title'], i['icon']));
    }
    return buttonDataList;
  }
}
